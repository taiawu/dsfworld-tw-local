---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(tidyverse)
```
```{r}
source("../2_add_layouts/support_scripts/layout_handling.R")
source("../1_upload_raw/support_scripts/upload_formatters.R")
```

```{r}
# given a file path to the layout, make the layout dataframe
lo384 <- make_layout("sample_layout.csv") %>%
        add_standardized_wells()

data_raw <- read.csv("sample_data_file.csv")

by_well <- nest_raw(data_raw) %>%
           add_standardized_wells()

by_well_layout <- join_layout_nest(by_well, lo384) 
by_well_layout
```

```{r}

#all(c("well_", "well_f_", "row_", "col_") %in% names(by_well))
ensure_standardized_wells <- function( df ) {
  if ( all(c("well_", "well_f_", "row_", "col_") %in% names(df)) == FALSE ) { # if standardized well columns are missing
    df_out <- df %>%
              add_standardized_wells()
  } else {
    df_out <- df
  }
  
  df_out 
}

by_well %>% ensure_standardized_wells()
rtable %>% ensure_standardized_wells()
```

```{r}
# the part that's failing
new_names <- readRDS("new_names_raw_handson.rds")
values_df_1 <- readRDS("values_df_1.rds")
new_names
values_df_1

join_layout_nest <- function(by_well, layout) { 
  by_well_ <- ensure_standardized_wells(by_well)
  layout_ <- ensure_standardized_wells(layout)
  dup_cols <- names(layout_)[!c(names(layout_) %in% c("well_", "well_f_", "row_", "col_"))]
  
  if (!"condition" %in% names(layout_)) {
    print("no_cond")
    layout_ <- layout_ %>%
                unite("condition", -one_of(c("well","well_", "well_f_", "row_", "col_")), remove = FALSE)
  }
  
  by_well_ %>%
    unnest_legacy() %>%
    dplyr::select(-one_of(dup_cols )) %>% # if it's already in layout, drop it
    dplyr::left_join(., layout_, by = c("well_", "well_f_", "row_", "col_")) %>%
    group_by(condition, Temperature) %>%
    dplyr::mutate(mean = mean(value),
                  sd = sd(value),
                  mean_norm = mean(value_norm),
                  sd_norm = sd(value_norm)) %>%
    ungroup() %>%
    nest(data = c(Temperature, value, mean, sd, Temperature_norm, value_norm, mean_norm, sd_norm)) # THIS IS NOT nest_legacy
}

join_layout_nest(values_df_1, new_names %>% dplyr::select(-condition))
new_names
```



```{r}
l_names <- c("a", "condition")
all(l_names[!l_names == "condition"] %in% c("a"))
    # common_cols <- c("well","well_", "well_f_", "row_", "col_", "row", "column") %>%
    #                 .[. %in% names(layout_)]
# all(c("a", "B") %in% c("b"))
# a <- c("well","well_", "well_f_", "row_", "col_", "row", "column") %>%
#   .[. %in% c("well","well_", "well_f_", "row_", "col_") ]
#  a 
#a[a %in% c(c("well","well_", "well_f_", "row_", "col_") )]

#c("well","well_", "well_f_", "row_", "col_", "row", "column") %in% c("well","well_", "well_f_", "row_", "col_", "row", "column") 
```

```{r}
names(new_names)[!c(names(new_names) %in% c("well_", "well_f_", "row_", "col_"))]
names(new_names)
c(names(new_names) %in% c("well_", "well_f_", "row_", "col_"))
```


```{r}
    # output$r_table <- renderRHandsontable({ 
    #     req(values$df)
    #     rhandsontable( values$df %>% select_if(is.character), height = 200, useTypes = TRUE, stretch = "all") %>% hot_col("well", readOnly = TRUE) #%>%  hot_context_menu(allowRowEdit = FALSE, allowColEdit = TRUE)
    # })
ensure_standardized_wells <- function( df ) {
  if ( all(c("well_", "well_f_", "row_", "col_") %in% names(df)) == FALSE ) { # if standardized well columns are missing
    df_out <- df %>%
              add_standardized_wells()
  } else {
    df_out <- df
  }
  
  df_out 
}
  
join_layout_nest <- function(by_well, layout) { 
  by_well_ <- ensure_standardized_wells(by_well)
  layout_ <- ensure_standardized_wells(layout)
  
  by_well_ %>%
    unnest_legacy() %>%
    dplyr::left_join(., layout_, by = c("well_", "well_f_", "row_", "col_")) %>%
    rename( well.original = well.x,
            well.layout = well.y ) %>%
    group_by(condition, Temperature) %>%
    dplyr::mutate(mean = mean(value),
                  sd = sd(value),
                  mean_norm = mean(value_norm),
                  sd_norm = sd(value_norm)) %>%
    ungroup() %>%
    nest(data = c(Temperature, value, mean, sd, Temperature_norm, value_norm, mean_norm, sd_norm)) # THIS IS NOT nest_legacy
}

handson_layout <- by_well %>%
          select_if(is.character) 

      if (! "condition" %in% names(handson_layout)) { 
            print("no condition")
            handson_layout <- handson_layout %>% 
                mutate(condition = .$well_)}
        print("end no condition")
        

# what if you overlay the same thing twice?
by_well_layout <- join_layout_nest(by_well, handson_layout) 
by_well_layout
```

```{r}
# # test the well translation function
# by_well_a1 <- by_well %>% mutate(well = c("a1", "a2", "a3"))
# by_well_A01 <- by_well %>% mutate(well = c("A01", "A02", "A03"))
# by_well_a01 <- by_well %>% mutate(well = c("a01", "a02", "a03"))
# 
# add_standardized_wells( by_well )
# add_standardized_wells( by_well_a1 )
# add_standardized_wells( by_well_A01 )
# add_standardized_wells( by_well_a01 )

# test the layouts 
# lo384E <- make_layout("sample_layout_empties.csv") # lets just keep the "empty" convention, since i don't know how different computers/excel versions deal with empty cells 
# lo96 <- make_layout("sample_layout_96.csv")
```



```{r}
## for plotting
join_layout_nest <- function(by_well, layout) { 
  by_well_ <- ensure_standardized_wells(by_well) # this will always be fresh, un-layout-joined dataframe
  layout_ <- ensure_standardized_wells(layout)
  l_names <- names(layout_)
  dup_cols <- l_names[!l_names %in% c("well_", "well_f_", "row_", "col_")]
  #dup_cols <- names(layout_)[!c(names(layout_) %in% c("well_", "well_f_", "row_", "col_"))]
  
  common_cols <- c("well","well_", "well_f_", "row_", "col_", "row", "column") %>%
                 .[. %in% names(layout_) ]

  if (!"condition" %in% names(layout_)) { # this should never happen....
    print("no_cond see join_layout_nest in layout_handling.R")
    layout_ <- layout_ %>%
                unite("condition", -one_of(c("well","well_", "well_f_", "row_", "col_", "row", "column")), remove = FALSE)
  } else { # if "condition" is present in the layout
    if (  all(l_names[!l_names == "condition"] %in% common_cols) == TRUE ) { # if "condition" is the only column unique to the layout
      common_cols <- c("well_", "well_f_", "row_", "col_", "row", "column") # retain the well column
      print("all names in common cols ZZ")
    } ### IX THIS--laout needs to have something left to combine
  }
  
    layout_ <- layout_ %>%
               select(-condition) %>%
               unite("condition", -one_of(common_cols), remove = FALSE) %>%
               mutate_if(is.factor, as.character)
  by_well_ %>%
    unnest_legacy() %>%
    dplyr::select(-one_of(dup_cols )) %>% # if it's already in layout, drop it
    dplyr::left_join(., layout_, by = c("well_", "well_f_", "row_", "col_")) %>%
    group_by(condition, Temperature) %>%
    dplyr::mutate(mean = mean(value),
                  sd = sd(value),
                  mean_norm = mean(value_norm),
                  sd_norm = sd(value_norm)) %>%
    ungroup() %>%
    nest(data = c(Temperature, value, mean, sd, Temperature_norm, value_norm, mean_norm, sd_norm)) # THIS IS NOT nest_legacy
}

get_layout_vars <- function( df ) {
  layout_vars <- names(df) %>%
              .[!. %in% c("well_", "well_f_", "row_", "col_", "row", "column", "data")]
  df %>%
    select( one_of(layout_vars) ) %>%
    plyr::mutate("-" = rep("", nrow(.)))
}
```

```{r}
choices <- list("one", "two", "three") # always stays the same; all possible options
chosen <- list("one", "two") # what has been actively selected

chosen_bool <- c(choices %in% chosen) %>% # convert this to a bool
                  as.list() %>%
                  set_names(choices) 
chosen_bool

chosen <- chosen_bool[chosen_bool == TRUE] %>% names()  # use the chosen bool to re-update chosen, as a list of names
chosen
```

```{r}

df_mt <- head(mtcars) %>%
  mutate(index = c(1:nrow(.)))

df_mt_t <- df_mt %>% 
  select(one_of("disp"))

mt_filt <- (df_mt_t %>% as_vector()) %in% c(160, 108) 

df_filt <- df_mt[mt_filt,]



df_mt_t2 <- df_mt %>% 
  select(one_of("mpg"))

mt_filt2 <- (df_mt_t2 %>% as_vector()) %in% c(21.0) 

df_filt2 <- df_mt[mt_filt2,]

df_final <- inner_join(df_filt, df_filt2)
df_filt
df_filt2
df_final

```
```{r}
a <- head(mtcars) %>% select(c(disp, cyl))
a

b <- head(mtcars) %>%
    select(c(disp, hp)) %>%
    rename(disp_ = "disp")

b

left_join(b, a, by = c("disp_" = "disp"))
```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

